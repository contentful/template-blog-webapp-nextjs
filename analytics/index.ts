// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/**
 * test2
 */
export interface DemoEvent {
    bestCompany?: string;
    [property: string]: any;
}

/**
 * test
 */
export interface Test {
    /**
     * Company
     */
    company?: string;
    /**
     * Name...
     */
    name: string;
    [property: string]: any;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toDemoEvent(json: string): DemoEvent {
        return cast(JSON.parse(json), r("DemoEvent"));
    }

    public static demoEventToJson(value: DemoEvent): string {
        return JSON.stringify(uncast(value, r("DemoEvent")), null, 2);
    }

    public static toTest(json: string): Test {
        return cast(JSON.parse(json), r("Test"));
    }

    public static testToJson(value: Test): string {
        return JSON.stringify(uncast(value, r("Test")), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
        if (key) {
                throw Error(`Invalid value for key "${key}". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
        }
        throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
        if (typ.jsonToJS === undefined) {
                const map: any = {};
                typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
                typ.jsonToJS = map;
        }
        return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
        if (typ.jsToJSON === undefined) {
                const map: any = {};
                typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
                typ.jsToJSON = map;
        }
        return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
        function transformPrimitive(typ: string, val: any): any {
                if (typeof typ === typeof val) return val;
                return invalidValue(typ, val, key);
        }

        function transformUnion(typs: any[], val: any): any {
                // val must validate against one typ in typs
                const l = typs.length;
                for (let i = 0; i < l; i++) {
                        const typ = typs[i];
                        try {
                                return transform(val, typ, getProps);
                        } catch (_) {}
                }
                return invalidValue(typs, val);
        }

        function transformEnum(cases: string[], val: any): any {
                if (cases.indexOf(val) !== -1) return val;
                return invalidValue(cases, val);
        }

        function transformArray(typ: any, val: any): any {
                // val must be an array with no invalid elements
                if (!Array.isArray(val)) return invalidValue("array", val);
                return val.map(el => transform(el, typ, getProps));
        }

        function transformDate(val: any): any {
                if (val === null) {
                        return null;
                }
                const d = new Date(val);
                if (isNaN(d.valueOf())) {
                        return invalidValue("Date", val);
                }
                return d;
        }

        function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
                if (val === null || typeof val !== "object" || Array.isArray(val)) {
                        return invalidValue("object", val);
                }
                const result: any = {};
                Object.getOwnPropertyNames(props).forEach(key => {
                        const prop = props[key];
                        const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
                        result[prop.key] = transform(v, prop.typ, getProps, prop.key);
                });
                Object.getOwnPropertyNames(val).forEach(key => {
                        if (!Object.prototype.hasOwnProperty.call(props, key)) {
                                result[key] = transform(val[key], additional, getProps, key);
                        }
                });
                return result;
        }

        if (typ === "any") return val;
        if (typ === null) {
                if (val === null) return val;
                return invalidValue(typ, val);
        }
        if (typ === false) return invalidValue(typ, val);
        while (typeof typ === "object" && typ.ref !== undefined) {
                typ = typeMap[typ.ref];
        }
        if (Array.isArray(typ)) return transformEnum(typ, val);
        if (typeof typ === "object") {
                return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
                        : typ.hasOwnProperty("arrayItems")    ? transformArray(typ.arrayItems, val)
                        : typ.hasOwnProperty("props")         ? transformObject(getProps(typ), typ.additional, val)
                        : invalidValue(typ, val);
        }
        // Numbers can be parsed by Date but shouldn't be.
        if (typ === Date && typeof val !== "number") return transformDate(val);
        return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
        return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
        return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
        return { arrayItems: typ };
}

function u(...typs: any[]) {
        return { unionMembers: typs };
}

function o(props: any[], additional: any) {
        return { props, additional };
}

function m(additional: any) {
        return { props: [], additional };
}

function r(name: string) {
        return { ref: name };
}

const typeMap: any = {
    "DemoEvent": o([
        { json: "bestCompany", js: "bestCompany", typ: u(undefined, "") },
    ], "any"),
    "Test": o([
        { json: "company", js: "company", typ: u(undefined, "") },
        { json: "name", js: "name", typ: "" },
    ], "any"),
};

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: `npm install --save-dev ajv`.
 */
import Ajv, { ErrorObject } from 'ajv'

/**
 * The analytics.js snippet should be available via window.analytics.
 * You can install it by following instructions at: https://segment.com/docs/sources/website/analytics.js/quickstart/
 * Make sure to also include the TypeScript declarations with: `npm install --dev @types/segment-analytics`
 */
 declare global {
    interface Window {
        analytics: SegmentAnalytics.AnalyticsJS
    }
}

/** The callback exposed by analytics.js. */
export type Callback = () => void

/** A dictionary of options. For example, enable or disable specific destinations for the call. */
export interface Options {
    /**
     * Selectivly filter destinations. By default all destinations are enabled.
     * https://segment.com/docs/sources/website/analytics.js/#selecting-destinations
     */
    integrations?: {
        [key: string]: boolean | { [key: string]: any }
    }
    /**
     * A dictionary of extra context to attach to the call.
     * https://segment.com/docs/spec/common/#context
     */
    context?: Context
}

/**
 * Context is a dictionary of extra information that provides useful context about a datapoint.
 * @see {@link https://segment.com/docs/spec/common/#context}
 */
export interface Context extends Record<string, any> {
    active?: boolean
    app?: {
        name?: string
        version?: string
        build?: string
    }
    campaign?: {
        name?: string
        source?: string
        medium?: string
        term?: string
        content?: string
    }
    device?: {
        id?: string
        manufacturer?: string
        model?: string
        name?: string
        type?: string
        version?: string
    }
    ip?: string
    locale?: string
    location?: {
        city?: string
        country?: string
        latitude?: string
        longitude?: string
        region?: string
        speed?: string
    }
    network?: {
        bluetooth?: string
        carrier?: string
        cellular?: string
        wifi?: string
    }
    os?: {
        name?: string
        version?: string
    }
    page?: {
        hash?: string
        path?: string
        referrer?: string
        search?: string
        title?: string
        url?: string
    }
    referrer?: {
        type?: string
        name?: string
        url?: string
        link?: string
    }
    screen?: {
        density?: string
        height?: string
        width?: string
    }
    timezone?: string
    groupId?: string
    traits?: Record<string, any>
    userAgent?: string
}

export type ViolationHandler = (
    message: Record<string, any>,
    violations: ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * This handler will log a warning message to the console.
 */
export const defaultValidationErrorHandler: ViolationHandler = (message, violations) => {
    const msg = JSON.stringify(
        {
            type: 'Typewriter JSON Schema Validation Error',
            description:
                `You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
                'Tracking Plan spec.',
            errors: violations,
        },
        undefined,
        2,
    );

    console.warn(msg);
};

let onViolation = defaultValidationErrorHandler

let analytics: () => SegmentAnalytics.AnalyticsJS | undefined = () => {
    return window.analytics;
};

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
    /**
     * Underlying analytics instance where analytics calls are forwarded on to.
     * Defaults to window.analytics.
     */
    analytics?: SegmentAnalytics.AnalyticsJS;
    /**
     * Handler fired when if an event does not match its spec. This handler
     * does not fire in production mode, because it requires inlining the full
     * JSON Schema spec for each event in your Tracking Plan.
     *
     * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
     * if a message does not match the spec. Otherwise, errors will be logged to stderr.
     */
    onViolation?: ViolationHandler;
}

/**
 * Updates the run-time configuration of this Typewriter client.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {AnalyticsJS} [analytics] - Underlying analytics instance where analytics
 * 		calls are forwarded on to. Defaults to window.analytics.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
    analytics = options.analytics ? () => options.analytics || window.analytics : analytics;
    onViolation = options.onViolation || onViolation
}

/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the `onViolation` handler will be called.
    */
function validateAgainstSchema(
    message: Record<string, any>,
    schema: object
) {
    const ajv = new Ajv({ allErrors: true, verbose: true })

    if (!ajv.validate(schema, message) && ajv.errors) {
        onViolation(message, ajv.errors)
    }
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message: Options = {}): Options {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                version: '8.1.0',
            },
        },
    };
}

/**
 * Fires a 'DemoEvent' track call.
 *
 * @param DemoEvent props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function demoEvent(props: DemoEvent, options?: Options, callback?: Callback): void {

    const schema = {"$id":"demoEvent","description":"test2","properties":{"bestCompany":{"$id":"/properties/bestCompany","description":"","type":"string"}},"type":"object"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('demoEvent', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'Test' track call.
 *
 * @param Test props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function test(props: Test, options?: Options, callback?: Callback): void {

    const schema = {"$id":"test","description":"test","properties":{"company":{"$id":"/properties/company","description":"Company","type":"string"},"name":{"$id":"/properties/name","description":"Name...","type":"string"}},"required":["name"],"type":"object"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('test', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}

const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {AnalyticsJS} [analytics] - Underlying analytics instance where analytics
     * 		calls are forwarded on to. Defaults to window.analytics.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,

    /**
     * Fires a 'DemoEvent' track call.
     *
     * @param DemoEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    demoEvent,
    /**
     * Fires a 'Test' track call.
     *
     * @param Test props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    test,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method as keyof typeof clientAPI];
        }

        return () => {
            console.warn(`⚠️  You made an analytics call (${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \`npx typewriter\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE`);
            const a = analytics();
            if (a) {
                a.track(
                    'Unknown Analytics Call Fired',
                    {
                        method,
                    },
                    withTypewriterContext(),
                );
            }
        };
    },
});

